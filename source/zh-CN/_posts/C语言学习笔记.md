---
title: C语言学习笔记
date: 2019-07-12 16:22:42
categories: C/C++
---

这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.

经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语
言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了... 虽然
我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知
新, 再次"速成"一下.

<!-- More -->

# 语句与行

C语言我感觉对格式要求蛮宽松的, 可以一行多个语句 (每个语句必须以`;`结尾), 也可以
跨行写语句(在行末写`\`折行), 不像python对缩进都有严格要求.

💡 要注意的是预编译指令必须一行不能写多个语句, 但可以折行.

# 注释

有两种方式

## 推荐的方式

👇这种注释可以跨行写, 也可以在行内写

```C
#include /*comment*/ <stdio.h>
/*comment
comment
comment*/
```

💡值得一提的是只要出现 **/\*** 就会被识别为注释的开始, 如果想把y除z指向的内存的
值赋给x写成下面这样是不行的.

```C
x = y/*z
```

但这个问题也很好解决, 用空格或括号就能解决.

```C
x = y / *z
x = y/(*z)
```

## 不推荐的方式

这样只能单行注释

```C
code  // comment
```

❗️要注意这种注释方式是借鉴自C++, 在C99中才被标准化, 而目前使用最广泛的是C89标准,
也就是说不使用是比较保险的.

# 内存

C语言对内存的操作似乎很多, 也很注重内存管理.

C语言为内存的分配和管理提供了几个函数. 这些函数可以在 <stdlib.h> 头文件中找到.

**void \*malloc(size_t size)** 分配一块`size`大小的内存

**void \*calloc(size_t num, size_t size)** 分配一块储存了一个`num`长, 每个元素
`size`字节的内存并将所有位初始化为0

**void \*realloc(void \*ptr, size_t size)** 重新分配内存，把内存扩展到 newsize

**void free(void \*ptr)** 释放`ptr`所指向的内存

💡 malloc是memory allocate, realloc是reallocate, calloc不知道是啥.

**栈**是由编译器在需要时分配的，不需要时自动清除的变量存储区. 里面的变量通常是局
部变量, 函数参数等. **堆**是由`malloc()`函数分配的内存块,内存释放由程序员手动控
制, 在C语言由`free()`完成.

# 字符串

很有意思的一个小问题: "5", '5' 和 5 有什么区别?  
"5"是一个字符串, '5'是一个字符常量, 5是一个数字常量

# 预处理

## 宏定义

```C
#define 宏名 字符串
```

宏名一般为大写, 以下划线连接单词.

看了网上资料我感觉在C中宏定义主要是以下作用

### 增加代码抽象性

用宏定义替代magic number, 或者嵌入式中一些寄存器的位操作, 一方面增强代码可读性
(不像魔数让人不明所以, 而寄存器的位操作也很不直观), 一方面增强代码可移植性 (比如从一种单片机移植到另一种单片机, 只需更改宏定义即可)

### 防止重复定义

```C
#ifndef XXXX
#define XXXX
...
#endif
```

在头文件里用这样的语句来防止头文件被重复引用. 有一些头文件被重复引用会增加编译器
工作, 降低编译效率, 而有一些头文件被重复引用会引起冲突 (比如如果头文件里定义了全
局变量, 会发生重复定义错误).

### 控制代码编译

通过Makefile控制编译选项.

还能像轮子哥[这样](https://www.zhihu.com/question/22608939/answer/21963056)当模
板用.

❗️虽然宏定义的好处不少, 但除了以上情况尽量少用尽量不用宏定义, 因为这会让开发者看
到的代码与编译器看到的代码不同, 容易导致想不到的问题.

# 调试技巧

调试时重点关注两方面: **当前行的跳转**, **变量的变化**

循环结构程序设计中最常见的两个问题: **算术运算溢出**, **程序效率低下**

变量在未赋值之前的值是不确定的.
